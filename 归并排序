#分而治之：分析原问题 - 解决子问题 - 合并问题解

  #归并排序
       #完整数组的切割
       #局部有序（每个元素天然有序）
       #两两合并
       
     #算法流程
     
        #1）：将数组A[1，n]排序问题分解为A[1,n/2]和A[n/2 + 1, n]的问题              分析原问题
        #2）：递归解决子问题得到两个有序的数组                                      解决子问题
        #3）：将两个有序数组自下而上合并                                           合并问题解
        
     #伪代码
        
        MergeSort(A,left,right){
        
          if (left > = right) 
            then
              return A[left,right]        #分割数组至仅有一个元素
          end

           mid = [(left+right)/2]

          #子数组排序
           MergeSort(A,left,mid)
           MergeSort(A,mid+1,right)

          #合并子数组
           Merge(A,left,mid,right)

           return A[left,right]
         }
         #合并数组
         Merge(A,left,mid,right){
         
          B[left,right] = A[left,right]       #初始化赋值
          i = left, j = mid+1, k= 0
          
          while (i<= left,j<= right) do   
            if B[i] < B[j] then
              A[left+k] = B[i]
              k++, i++
            else
              A[left+k] = B[j]
              K++,j++
              
          if(i < mid) then                #一边走完，剩余元素全部补全
            A[left+k,right] = B[i,mid]    #B[i,mid] 已有序
          else
            A[left+k,right] = B[j,right]
            
          return A[left,right]
         
     #时间复杂度分析
        Merge() - 每个元素仅遍历一次 - -  O（n）
        MergeSort（）
                            O（1）              n=1
              T(n) 问题规模 =         
                            2T（n/2）+ O(n)     n>1
         
              
              
                      O(n)                   O(n)
                 2T(n/2)  2T(n/2)      O(n/2)  O(n/2)       O(n)
                                     4T(n/4)   4T(n/4)      O(n)            logN 层 
                                            ……
                                     O（1） O(1) ...         O(n)
        
        
        故时间复杂度为O(n)*logn = O(nlogn)
         
         
         
         
  #Python 实现代码

A = [9,8,7,6,5,4,3,2,1,0]
print(A)

def MergeSort(A):                   #递归分解问题
    if len(A)<=1 :                  #分解至组元
        return A

    mid = len(A)//2
    AL=MergeSort(A[:mid])           #左数组
    AR=MergeSort(A[mid:])           #右数组
    return Merge(AL,AR)

def Merge(AL,AR):                  #归并函数

    i=0;j=0;k=0;
    result = []                     #合并的结果将存至此数组返回

    while i<len(AL) and j<len(AR):  #两指针分别计数
        if AL[i]<= AR[j]:           #左小于右时
            result.append (AL[i])   #将左存储在结果数组中（升序）
            i=i+1                   #循环变量加1
        else:
            result.append(AR[j])    #否则，将右存储
            j=j+1

    if i < len(AL):                #当右某一数组添加完毕，将左数组剩余数据存贮
        result += AL[i:]
    else:
        result += AR[j:]
    return result

print(MergeSort(A))
